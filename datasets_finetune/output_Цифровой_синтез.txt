Блок кода Verilog:
module b1_mux_2_1_comb
(
input d0,
input d1,
input sel,
output y
);
 
assign y = (sel & d1) | ((~sel) & d0);
endmodule
Описание листинга:
Листинг 4.1 Комбинационный мультиплексор 2в1
-----

Блок кода Verilog:
module b1_mux_2_1_sel
(
 
input d0,
input d1,
input sel,
output y
);
 
assign y = sel ? d1 : d0;
endmodule
Описание листинга:
Листинг 4.2 Мультиплексор 2в1 на основе тернарного оператора
-----

Блок кода Verilog:
module b1_mux_2_1_if
(
 
input d0, 
input d1, 
input sel, 
output reg y
);
 
always@(*)
begin
if(sel)
y = d1;
else
y = d0;
end
endmodule
Описание листинга:
Листинг 4.3 Мультиплексор 2в1 на основе условного оператора
-----

Блок кода Verilog:
module b1_mux_2_1_case
(
input d0,
input d1,
input sel,
output reg y
);
 
always@(*)
begin
case (sel)

0: y = d0;
 
 
 
 
1: y = d1;
 
 
 
endcase
 
 
end
endmodule
Описание листинга:
Листинг 4.4 Мультиплексор 2в1 на основе оператора множественного выбора
-----

Блок кода Verilog:
module which only task is to test another module
// testbench is for simulation only, not for synthesis
module testbench;
 
// input and output test signals
 
reg a;
 
reg b;
 
reg sel;
 
wire y_comb;
 
wire y_sel;
 
wire y_if;
 
wire y_case;
 
// creating the instance of the module we want to test
 
b1_mux_2_1_comb b1_mux_2_1_comb (a, b, sel, y_comb);
 
b1_mux_2_1_sel b1_mux_2_1_sel (a, b, sel, y_sel);
 
b1_mux_2_1_if b1_mux_2_1_if (a, b, sel, y_if);
 
b1_mux_2_1_case b1_mux_2_1_case (a, b, sel, y_case);
 
initial 
 
 
begin
 
 
 
a = 1’b0;
 
 
 
b = 1’b1;
 
 
 
#5;
 
 
 
sel = 1’b0; // sel change to 0; a -> y
 
 
 
#10;
 
 
 
sel = 1’b1; // sel change to 1; b -> y
 
 
 
#10
 
 
 
b = 1’b0; // b change; y changes too. sel == 1’b1
 
 
 
#5
 
 
 
b = 1’b1;
 
 
 
#5; // pause
 
 
end
 
// do at the beginning of the simulation
 
// print signal values on every change
 
initial 
 
 
$monitor("a=%b b=%b sel=%b y_comb=%b y_sel=%b y_if=%b y_case=%b", 
 
 
 
 
a, b, sel, y_comb, y_sel, y_if, y_case);
 
// do at the beginning of the simulation
 
initial 
 
 
$dumpvars; //iverilog dump init
endmodule
Описание листинга:
Листинг 4.5 Тестбенч для моделирования различных реализаций однобитных 
-----

Блок кода Verilog:
module b1_mux_2_1_concate
(
 
input d0,
 
input d1,
 
input sel,
 
output y
);
 
wire [1:0] dataIn;
 
assign dataIn = {d1,d0};
 
assign y = dataIn[sel];
endmodule
Описание листинга:
Листинг 4.6 Мультиплексор 2в1, реализованный с помощью операции конкатенации
-----

Блок кода Verilog:
module b2_mux_2_1_case
(
 
input [1:0] d0,
 
input [1:0] d1,
 
input sel,
 
output reg [1:0] y
);
 
always@(*)
 
 
begin
 
 
 
case (sel)
 
 
 
 
0: y = d0;
 
 
 
 
1: y = d1;
 
 
 
endcase
 
 
end
endmodule
Описание листинга:
Листинг 4.7 Двухбитный мультиплексор 2в1, реализованный с помощью  
-----

Блок кода Verilog:
module b2_mux_2_1_comb_incorrect
(
 
input [1:0] d0,
 
input [1:0] d1,
 
input sel,
 
output [1:0] y
);
 
assign y = (sel & d1) | ((~sel) & d0);
endmodule
Описание листинга:
Листинг 4.8 Некорректный комбинационный двухбитный мультиплексор 2в1
-----

Блок кода Verilog:
module b2_mux_2_1_comb_correct2
(
 
input [1:0] d0,
 
input [1:0] d1,
 
input sel,
 
output [1:0] y
);
 
wire [1:0] select;
 
assign select = {2{sel}};
 
assign y = (select & d1) | (~select & d0);
endmodule
Описание листинга:
Листинг 4.9 Правильный комбинационный двухбитный мультиплексор 2в1
-----

Блок кода Verilog:
module b2_mux_4_1_case
(
 
input [1:0] d0, d1, d2, d3,
 
input [1:0] sel,
 
output reg [1:0] y
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: y = d0;
 
 
 
2’b01: y = d1;
 
 
 
2’b10: y = d2;
 
 
 
2’b11: y = d3;
 
 
endcase
endmodule
Описание листинга:
Листинг 4.10 Двухбитный мультиплексор 4в1, реализованный  
-----

Блок кода Verilog:
module b2_mux_4_1_sel
(
 
input [1:0] d0, d1, d2, d3,
 
input [1:0] sel,
 
output [1:0] y
);
 
assign y = sel [1] ? (sel [0] ? d3 : d2)
 
 
 
: (sel [0] ? d1 : d0);
endmodule
Описание листинга:
Листинг 4.11 Двухбитный мультиплексор 4в1, реализованный  
-----

Блок кода Verilog:
module b2_mux_4_1_block
(
 
input [1:0] d0, d1, d2, d3,
 
input [1:0] sel,
 
output [1:0] y
);
 
wire [1:0] w01, w23;
 
b2_mux_2_1_sel mux0(.d0(d0), .d1(d1), .sel(sel[0]), .y(w01));
 
b2_mux_2_1_sel mux1(.d0(d2), .d1(d3), .sel(sel[0]), .y(w23));
 
b2_mux_2_1_sel mux2(.d0(w01), .d1(w23), .sel(sel[1]), .y(y));
endmodule
Описание листинга:
Листинг 4.12 Двухбитный модульный мультиплексор 4в1
-----

Блок кода Verilog:
module b2_mux_4_1_block_alt
(
 
input [1:0] d0, d1, d2, d3,
 
input [1:0] sel,
 
output [1:0] y
);

 
b1_mux_4_1_case hi(.d0(d0[1]), .d1(d1[1]), .d2(d2[1]), .d3(d3[1]), 
 
 
.sel(sel), .y(y[1]));
 
b1_mux_4_1_case lo(.d0(d0[0]), .d1(d1[0]), .d2(d2[0]), .d3(d3[0]), 
 
 
.sel(sel), .y(y[0]));
endmodule
Описание листинга:
Листинг 4.13 Альтернативная реализация двухбитного модульного мультиплексора 4в1
-----

Блок кода Verilog:
module b2_mux_3_1_case_latch
(
 
input [1:0] d0, d1, d2, 
 
input [1:0] sel,
 
output reg [1:0] y
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: y = d0;
 
 
 
2’b01: y = d1;
 
 
 
2’b10: y = d2;
 
 
endcase
endmodule
Описание листинга:
Листинг 4.14 Мультиплексор 3в1 с защелкой
-----

Блок кода Verilog:
module b2_mux_3_1_case_correct
(
 
input [1:0] d0, d1, d2, 
 
input [1:0] sel,
 
output reg [1:0] y
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: y = d0;
 
 
 
2’b01: y = d1;
 
 
 
default: y = d2;
 
 
endcase
endmodule
Описание листинга:
Листинг 4.15 Мультиплексор 3в1 без защелки
-----

Блок кода Verilog:
module b2_mux_3_1_casex_correct
(
 
input [1:0] d0, d1, d2, 
 
input [1:0] sel,
 
output reg [1:0] y
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: y = d0;
 
 
 
2’b01: y = d1;
 
 
 
2’b10: y = d2;
 
 
 
default: y=2’bxx;
 
 
endcase
endmodule
Описание листинга:
Листинг 4.16 Мультиплексор 3в1 с х-состоянием
-----

Блок кода Verilog:
module b1_demux_1_4_shift
(
 
input din, 
 
input [1:0] sel,
 
output reg dout0, 
 
output reg dout1,
 
output reg dout2,
 
output reg dout3
);
 
always @(*)
 
 
{dout3, dout2, dout1, dout0}= din<<sel
endmodule
Описание листинга:
Листинг 4.17 Демультиплексор 1в4 с одноразрядным сдвигом
-----

Блок кода Verilog:
module b1_demux_1_4_case
(
 
input din, 
 
input [1:0] sel,
 
output reg dout0, 
 
output reg dout1,
 
output reg dout2,
 
output reg dout3
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: 
 
 
 
begin
 
 
 
 
dout0 = din;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b01:
 
 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = din;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b10:

 
 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = din;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b11: 
 
 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = din;
 
 
 
end
 
 
endcase
endmodule
Описание листинга:
Листинг 4.18 Однобитный демультиплексор 1в4, реализованный  
-----

Блок кода Verilog:
module b1_demux_1_4_case
(
 
input din, 
 
input [1:0] sel,
 
output reg dout0, 
 
output reg dout1,
 
output reg dout2,
 
output reg dout3
);
 
always @(*)
 
 
case (sel)
 
 
 
2’b00: 
 
 
 
begin
 
 
 
 
dout0 = din;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b01:
 
 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = din;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b10:

 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = din;
 
 
 
 
dout3 = 0;
 
 
 
end
 
 
 
2’b11: 
 
 
 
begin
 
 
 
 
dout0 = 0;
 
 
 
 
dout1 = 0;
 
 
 
 
dout2 = 0;
 
 
 
 
dout3 = din;
 
 
 
end
 
 
endcase
endmodule
Описание листинга:
Листинг 4.19 N-битный параметризованный демультиплексор, реализованный 
-----

Блок кода Verilog:
module bn_demux_1_4_case
#(parameter DATA_WIDTH=2)
(
 
input [DATA_WIDTH-1:0] din, 
 
input [1:0] sel,
 
output reg [DATA_WIDTH-1:0] dout0, 
 
output reg [DATA_WIDTH-1:0] dout1,
 
output reg [DATA_WIDTH-1:0] dout2,
 
output reg [DATA_WIDTH-1:0] dout3
);
Листинг 4.19 N-битный параметризованный демультиплексор, реализованный 
с помощью оператора case
Задавая значение параметра DATA_WIDTH (в коде листинга 4.20 это выглядит 
как #(2) для двухбитной реализации), можно получить демультиплексор с необ-
ходимой размерностью входов и выходов.
module lab4
(
 
input [ 1:0] KEY,
 
input [ 9:0] SW,
 
output [ 9:0] LEDR
);
`ifdef CASE 
 
bn_demux_1_4_case #(2) bn_demux_1_4_case (.din(SW[1:0]), 
 
 
.sel(KEY[1:0]), 
 
.dout0(LEDR[1:0]), .dout1(LEDR[3:2]), .dout2(LEDR[5:4]), 
 
 
.dout3(LEDR[7:6]));
`else
 
b2_demux_1_4_block b2_demux_1_4_block (.din(SW[1:0]), 
 
 
.sel(KEY[1:0]), 
 
.dout0(LEDR[1:0]), .dout1(LEDR[3:2]), .dout2(LEDR[5:4]), 
 
 
.dout3(LEDR[7:6]));
`endif
endmodule
Описание листинга:
Листинг 4.20 Пример модуля с конкретизацией параметров и директивами  
-----

Блок кода Verilog:
module b2_demux_1_4_block
(
 
input [1:0] din, 
 
input [1:0] sel,
 
output [1:0] dout0, 
 
output [1:0] dout1,
 
output [1:0] dout2,
 
output [1:0] dout3
);
 
b1_demux_1_4_case dmux0 (.din(din[0]), .sel(sel), .dout0(dout0[0]), 
 
 
.dout1(dout1[0]), .dout2(dout2[0]), .dout3(dout3[0]));
 
b1_demux_1_4_shift dmux1 (.din(din[1]), .sel(sel), .dout0(dout0[1]), 
 
 
.dout1(dout1[1]), .dout2(dout2[1]), .dout3(dout3[1]));
endmodule
Описание листинга:
Листинг 4.21 Двухбитный модульный демультиплексор 1в4
-----

Блок кода Verilog:
module bn_select_8_1_case
#(parameter DATA_WIDTH=8)
(
 
input [DATA_WIDTH-1:0] d0, 
 
input [DATA_WIDTH-1:0] d1,
 
input [DATA_WIDTH-1:0] d2,
 
input [DATA_WIDTH-1:0] d3,
 
input [DATA_WIDTH-1:0] d4, 
 
input [DATA_WIDTH-1:0] d5,
 
input [DATA_WIDTH-1:0] d6,
 
input [DATA_WIDTH-1:0] d7,
 
input [7:0] sel,
 
output reg [DATA_WIDTH-1:0] y
);
 
always @(*)
 
 
case (sel)
 
 
 
8’b00000001: y=d0;
 
 
 
8’b00000010: y=d1;
 
 
 
8’b00000100: y=d2;
 
 
 
8’b00001000: y=d3;
 
 
 
8’b00010000: y=d4;
 
 
 
8’b00100000: y=d5;
 
 
 
8’b01000000: y=d6;
 
 
 
8’b10000000: y=d7;
 
 
 
default: y={DATA_WIDTH{1’bx}};
 
 
endcase
endmodule
Описание листинга:
Листинг 4.22 N-битный селектор 8в1
-----

Блок кода Verilog:
module bn_mux_n_1_generate
#( parameter DATA_WIDTH = 8,
 
parameter SEL_WIDTH = 2) 
(
 
input [((2**SEL_WIDTH)*DATA_WIDTH)-1:0] data,
 
input [SEL_WIDTH-1:0] sel, 
 
output [DATA_WIDTH-1:0] y
);
wire [DATA_WIDTH-1:0] tmp_array [0:(2**SEL_WIDTH)-1];
genvar i;
generate
 
for(i=0; i<2**SEL_WIDTH; i=i+1) 
 
begin: gen_array
 
 
assign tmp_array[i] = data[((i+1)*DATA_WIDTH)-1:(i*DATA_WIDTH)];
 
end
endgenerate
 
assign y = tmp_array[sel];
endmodule
Описание листинга:
Листинг 4.23 Полностью параметризированный мультиплексор
-----

Блок кода Verilog:
module bn_selector_n_1_generate 
#( parameter DATA_WIDTH = 8,
 
parameter INPUT_CHANNELS = 2) 
(
 
input [(INPUT_CHANNELS*DATA_WIDTH)-1:0] data,
 
input [INPUT_CHANNELS-1:0] sel, 
 
output [DATA_WIDTH-1:0] y
);
genvar i;
generate
 
for(i=0;i<INPUT_CHANNELS;i=i+1) 
 
begin: gen_array
 
 
assign y = sel[i] ? data[((i+1)*DATA_WIDTH)-1:(i*DATA_WIDTH)] :  
 
 
 
{DATA_WIDTH{1’bx}};
 
end
endgenerate
endmodule
Описание листинга:
Листинг 4.24 Полностью параметризированный селектор
-----

Блок кода Verilog:
module bn_selector_4_1_and_or 
#( parameter DATA_WIDTH = 32) 
(
 
input [(DATA_WIDTH*4)-1:0] data,
 
input [3:0] sel, 
 
output [DATA_WIDTH-1:0] y
);
 
wire [(DATA_WIDTH*4)-1:0] mask;
 
wire [(DATA_WIDTH*4)-1:0] masked_data;
 
assign mask = {{DATA_WIDTH{sel[3]}}, 
 
 
{DATA_WIDTH{sel[2]}}, 
 
 
{DATA_WIDTH{sel[1]}}, 
 
 
{DATA_WIDTH{sel[0]}}};
 
assign masked_data = data & mask;
 
assign y = masked_data[DATA_WIDTH*4-1:DATA_WIDTH*3]|
 
 
masked_data[DATA_WIDTH*3-1:DATA_WIDTH*2]|
 
 
masked_data[DATA_WIDTH*2-1:DATA_WIDTH]|
 
 
masked_data[DATA_WIDTH-1:0];
endmodule
Описание листинга:
Листинг 4.25 И-ИЛИ селектор
-----

Блок кода Verilog:
module bn_selector_4_1_and_or 
#( parameter DATA_WIDTH = 32) 
(
 
input [(DATA_WIDTH*4)-1:0] data,
 
input [3:0] sel, 
 
output [DATA_WIDTH-1:0] y
);
 
wire [(DATA_WIDTH*4)-1:0] mask;
 
wire [(DATA_WIDTH*4)-1:0] masked_data;
 
assign mask = {{DATA_WIDTH{sel[3]}}, 
 
 
{DATA_WIDTH{sel[2]}}, 
 
 
{DATA_WIDTH{sel[1]}}, 
 
 
{DATA_WIDTH{sel[0]}}};
 
assign masked_data = data & mask;
 
assign y = masked_data[DATA_WIDTH*4-1:DATA_WIDTH*3]|
 
 
masked_data[DATA_WIDTH*3-1:DATA_WIDTH*2]|
 
 
masked_data[DATA_WIDTH*2-1:DATA_WIDTH]|
 
 
masked_data[DATA_WIDTH-1:0];
endmodule
Описание листинга:
Листинг 10.1 Функциональная модель модуля возведения числа в степень
-----

Блок кода Verilog:
module bn_selector_4_1_and_or 
#( parameter DATA_WIDTH = 32) 
(
 
input [(DATA_WIDTH*4)-1:0] data,
 
input [3:0] sel, 
 
output [DATA_WIDTH-1:0] y
);
 
wire [(DATA_WIDTH*4)-1:0] mask;
 
wire [(DATA_WIDTH*4)-1:0] masked_data;
 
assign mask = {{DATA_WIDTH{sel[3]}}, 
 
 
{DATA_WIDTH{sel[2]}}, 
 
 
{DATA_WIDTH{sel[1]}}, 
 
 
{DATA_WIDTH{sel[0]}}};
 
assign masked_data = data & mask;
 
assign y = masked_data[DATA_WIDTH*4-1:DATA_WIDTH*3]|
 
 
masked_data[DATA_WIDTH*3-1:DATA_WIDTH*2]|
 
 
masked_data[DATA_WIDTH*2-1:DATA_WIDTH]|
 
 
masked_data[DATA_WIDTH-1:0];
endmodule
Описание листинга:
Листинг 10.2 Тестовый вывод функциональной модели модуля  
-----

Блок кода Verilog:
module pow_5_single_cycle_struct
# (
 
parameter w = 8
)
(
 
input clk,
 
input rst_n,
 
input arg_vld,
 
input [w - 1:0] arg,
 
output res_vld,
 
output [w - 1:0] res
);
 
wire arg_vld_q;
 
wire [w - 1:0] arg_q;
 
reg_rst_n i_arg_vld (clk, rst_n, arg_vld, arg_vld_q);
 
reg_no_rst # (w) i_arg (clk, arg, arg_q);
 
wire res_vld_d = arg_vld_q;
 
wire [w - 1:0] res_d = arg_q * arg_q * arg_q * arg_q * arg_q;
 
reg_rst_n i_res_vld (clk, rst_n, res_vld_d, res_vld);
 
reg_no_rst # (w) i_res (clk, res_d, res);
endmodule
Описание листинга:
Листинг 10.3 Исходный код комбинационной реализации модуля  
-----

Блок кода Verilog:
module pow_5_multi_cycle_struct
# ( parameter w = 8 )
(
 
input clk,
 
input rst_n,
 
input arg_vld,
 
input [w - 1:0] arg,
 
output res_vld,
 
output [w - 1:0] res
);
 
wire arg_vld_q;
 
wire [w - 1:0] arg_q;
 
reg_rst_n i_arg_vld (clk, rst_n, arg_vld, arg_vld_q);
 
reg_no_rst_en # (w) i_arg (clk, arg_vld, arg, arg_q);
 
wire [3:0] shift_q;
 
wire [3:0] shift_d = arg_vld_q ? 4’b1000 : shift_q >> 1;
 
reg_rst_n # (4) i_shift (clk, rst_n, shift_d, shift_q);
 
assign res_vld = shift_q [0];
 
wire [w - 1:0] mul_q;
 
wire [w - 1:0] mul_d = (arg_vld_q ? arg_q : mul_q) * arg_q;
 
wire mul_en = arg_vld_q || shift_q [3:1] != 3’b0;
 
reg_no_rst_en # (w) i_mul (clk, mul_en, mul_d, mul_q);
 
assign res = mul_q;
endmodule
Описание листинга:
Листинг 10.4 Исходный код многотактной реализации модуля  
-----

Блок кода Verilog:
module pow_5_pipe_struct
# (
 
parameter w = 8
)
(
 
input clk,
 
input rst_n,
 
input arg_vld,
 
input [ w - 1:0] arg,
 
output [ 4:0] res_vld,
 
output [5 * w - 1:0] res
);
 
wire arg_vld_q_1;
 
wire [w - 1:0] arg_q_1;
 
reg_rst_n i0_arg_vld (clk, rst_n, arg_vld, arg_vld_q_1);
 
reg_no_rst # (w) i0_arg (clk, arg, arg_q_1);
 
assign res_vld [4 ] = arg_vld_q_1;
 
assign res [4 * w +: w] = arg_q_1;
//--------------------------------------------------------------------
 
wire [w - 1:0] mul_d_1 = arg_q_1 * arg_q_1;
 
wire arg_vld_q_2;
 
wire [w - 1:0] arg_q_2;
 
wire [w - 1:0] mul_q_2;
 
reg_rst_n i1_arg_vld ( clk , rst_n , arg_vld_q_1 , arg_vld_q_2 );
 
reg_no_rst # (w) i1_arg ( clk , arg_q_1 , arg_q_2 );
 
reg_no_rst # (w) i1_mul ( clk , mul_d_1 , mul_q_2 );
 
assign res_vld [3 ] = arg_vld_q_2;
 
assign res [3 * w +: w] = mul_q_2;
//--------------------------------------------------------------------
 
wire [w - 1:0] mul_d_2 = mul_q_2 * arg_q_2;
 
wire arg_vld_q_3;
 
wire [w - 1:0] arg_q_3;
 
wire [w - 1:0] mul_q_3;
 
reg_rst_n i2_arg_vld ( clk , rst_n , arg_vld_q_2 , arg_vld_q_3 );
 
reg_no_rst # (w) i2_arg ( clk , arg_q_2 , arg_q_3 );
 
reg_no_rst # (w) i2_mul ( clk , mul_d_2 , mul_q_3 );
 
assign res_vld [2 ] = arg_vld_q_3;
 
assign res [2 * w +: w] = mul_q_3;
//--------------------------------------------------------------------
 
wire [w - 1:0] mul_d_3 = mul_q_3 * arg_q_3;
 
wire arg_vld_q_4;
 
wire [w - 1:0] arg_q_4;
 
wire [w - 1:0] mul_q_4;
 
reg_rst_n i3_arg_vld ( clk , rst_n , arg_vld_q_3 , arg_vld_q_4 );
 
reg_no_rst # (w) i3_arg ( clk , arg_q_3 , arg_q_4 );
 
reg_no_rst # (w) i3_mul ( clk , mul_d_3 , mul_q_4 );
 
assign res_vld [1 ] = arg_vld_q_4;
 
assign res [1 * w +: w] = mul_q_4;
//--------------------------------------------------------------------
 
wire [w - 1:0] mul_d_4 = mul_q_4 * arg_q_4;
 
wire arg_vld_q_5;
 
wire [w - 1:0] arg_q_5;
 
wire [w - 1:0] mul_q_5;
 
reg_rst_n i4_arg_vld ( clk , rst_n , arg_vld_q_4 , arg_vld_q_5 );
 
reg_no_rst # (w) i4_arg ( clk , arg_q_4 , arg_q_5 );
 
reg_no_rst # (w) i4_mul ( clk , mul_d_4 , mul_q_5 );
 
assign res_vld [0 ] = arg_vld_q_5;
 
assign res [0 * w +: w] = mul_q_5;
endmodule
Описание листинга:
Листинг 10.5 Исходный код конвейерной реализации модуля  
-----

